<!DOCTYPE html>
<html>
<head>
<title>03-Create-New-Artist-Controller.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
          ? 'dark'
          : 'default'
    });
  </script>
<h1 id="create-new-artist-controller-crud-operations--action-methods">Create New Artist Controller, CRUD Operations &amp; Action Methods</h1>
<p><strong>Note:</strong> My RecordDb database is an existing database and was made with singular table names. For this reason my <code>DbSet</code> names are singular as well. In ASP.Net Core and EntityFramework the Domains are usually plural.</p>
<h2 id="create-the-artists-controller">Create the Artists Controller</h2>
<p>Remember to use the Empty API Controller template.</p>
<pre class="hljs"><code><div>    namespace RecordDb.API.Controllers
    {
        [Route(<span class="hljs-string">"api/[controller]"</span>)]
        [ApiController]
        public class ArtistsController : ControllerBase
        {    
        }
    }
</div></code></pre>
<p>The annotations are important (using an API Controller template creates these).</p>
<blockquote>
<p>[Route(&quot;api/[controller]&quot;)]</p>
</blockquote>
<p>This annotation denotes the route for the controller. In our case this will be.</p>
<blockquote>
<p><a href="https://localhost:1234/api/artists">https://localhost:1234/api/artists</a></p>
</blockquote>
<p>This Url is going to the <code>artists</code> controller.</p>
<p><code>artists</code> is from the prefix of the controller name (ArtistsController.cs).</p>
<p>We could also change this annotation to.</p>
<blockquote>
<p>[Route(&quot;api/artists&quot;)]</p>
</blockquote>
<p>And it would work just the same.</p>
<p>The following annotation denotes that the controller is an API controller (not an MVC controller).</p>
<blockquote>
<p>[ApiController]</p>
</blockquote>
<p><strong>Note:</strong> if this annotation is missing you won't see any endpoints in Swagger.</p>
<h2 id="creating-a-dbcontext">Creating a DbContext</h2>
<p>We will create a DbContext to retrieve our Artist data using  constructor injection.</p>
<pre class="hljs"><code><div>    private <span class="hljs-built_in">readonly</span> RecordDbContext dbContext;

    public ArtistsController(RecordDbContext dbContext)
    {
        this.dbContext = dbContext;
    }
</div></code></pre>
<p>Now we can use the <code>dbContext</code> in our Action methods.</p>
<h2 id="creating-an-action-method">Creating an Action Method</h2>
<p>This is the route to get all Artists.</p>
<pre class="hljs"><code><div>    // GET: https://localhost:1234/api/artists
    [HttpGet]
    public async Task&lt;IActionResult&gt; <span class="hljs-function"><span class="hljs-title">GetAll</span></span>()
    {
        var artists = await dbContext.Artist.ToListAsync();

        <span class="hljs-built_in">return</span> Ok(artists);
    }
</div></code></pre>
<p>We use a <code>[HttpGet]</code> verb as our attribute.</p>
<p>We have access to our two domains through our <code>dbContext</code> so we can bring back the Artist data using the ToListAsync() method.</p>
<p>Run the code and a Swagger page will appear in your browser.</p>
<p><img src="assets/images/swagger-artist-endpoint.jpg" alt="Swagger Artist endpoint" title="Swagger Artist endpoint"></p>
<p>When you execute this endpoint it will return.</p>
<p><img src="assets/images/results.jpg" alt="Endpoint results" title="Endpoint results"></p>
<p>The data is returned as JSON.</p>
<pre class="hljs"><code><div>    {
        <span class="hljs-string">"artistId"</span>: 1,
        <span class="hljs-string">"firstName"</span>: <span class="hljs-string">"William"</span>,
        <span class="hljs-string">"lastName"</span>: <span class="hljs-string">"Ackerman"</span>,
        <span class="hljs-string">"name"</span>: <span class="hljs-string">"William Ackerman"</span>,
        <span class="hljs-string">"biography"</span>: <span class="hljs-string">"&lt;p&gt;Will Ackerman has gained..."</span>
    },
</div></code></pre>
<p>Also note that the Swagger returns a <code>Url</code> and a <code>curl</code> instruction and you can use either of these to return data.</p>
<blockquote>
<p><a href="https://localhost:7262/api/Artists">https://localhost:7262/api/Artists</a></p>
</blockquote>
<p>And.</p>
<blockquote>
<p>curl -X 'GET' '<a href="https://localhost:7262/api/Artists">https://localhost:7262/api/Artists</a>' -H 'accept: <em>/</em>'</p>
</blockquote>
<h2 id="getting-an-artist-by-id">Getting an Artist by Id</h2>
<p>For this Action method we will have to supply an <code>Id</code> to return a single Artist.</p>
<pre class="hljs"><code><div>    // GET: https://localhost:1234/api/artists/114
    [HttpGet]
    [Route(<span class="hljs-string">"{id:int}"</span>)]
    public async Task&lt;IActionResult&gt; GetById([FromRoute] int id)
    {   
        var artist = await dbContext.Artist.FindAsync(id);

        <span class="hljs-keyword">if</span> (artist == null)
        {
            <span class="hljs-built_in">return</span> NotFound($<span class="hljs-string">"An Artist with Id: {id} wasn't found!"</span>);

        <span class="hljs-built_in">return</span> Ok(artist);
    }
</div></code></pre>
<h3 id="code-breakdown">Code breakdown</h3>
<p>Once again we are using a <code>[HttpGet]</code> verb.</p>
<p>This time we need to receive a parameter of <code>Id</code> to find a particular Artist. We do this by adding a <code>Route</code> attribute in this format.</p>
<blockquote>
<p>[Route(&quot;{id:int}&quot;)]</p>
</blockquote>
<p><strong>Note:</strong> the parameter name (<code>id</code>) in the Route <strong>must</strong> match the method's input parameter name (see below).</p>
<pre class="hljs"><code><div>    [Route(<span class="hljs-string">"{id:int}"</span>)]
    public async Task&lt;IActionResult&gt; GetById([FromRoute] int id)
    {
        ...
    }
</div></code></pre>
<p>Also note that in the Route attribute we can make the parameter type safe by adding the <code>int</code> type.</p>
<p>In the method signature we know that the parameter is coming in from the Route so we can use the property <code>[FromRoute]</code> in front of the input parameter.</p>
<p>The next line allows us to find and return the Artist record if it is found.</p>
<pre class="hljs"><code><div>    var artist = await dbContext.Artist.FindAsync(id);
</div></code></pre>
<p>The <code>FindAsync()</code> method requires an input parameter that has to be the Primary Key for the Entity.</p>
<p>We can also use the following method to return the Artist record.</p>
<pre class="hljs"><code><div>    var artist = await dbContext.Artist.FirstOrDefaultAsync(a =&gt; a.ArtistId == id);
</div></code></pre>
<p>In this statement we use a LINQ query method, <code>.FirstOrDefault()</code> where we query the input parameter against the parameter in the database.</p>
<p>The benefit of using this method is that we are not tied to using just the <code>id</code> as a parameter. We could also use other parameters for the search such as the <code>Name</code> parameter, for example.</p>
<pre class="hljs"><code><div>    // GET: https://localhost:1234/api/artists/Yes
    [HttpGet]
    [Route(<span class="hljs-string">"{name:alpha}"</span>)]
    public async Task&lt;IActionResult&gt; GetById([FromRoute] string name)
    {
        var artist = await dbContext.Artist.FirstOrDefaultAsync(a =&gt; a.Name == name);
    
        <span class="hljs-keyword">if</span> (artist == null)
        {
            <span class="hljs-built_in">return</span> NotFound($<span class="hljs-string">"An Artist with Name: {name} wasn't found!"</span>);
        }
    
        <span class="hljs-built_in">return</span> Ok(artist);
    }
</div></code></pre>
<p>Once we have returned the result we need to test that a valid Artist has been returned.</p>
<p>In the following code we have returned a response of <strong>200</strong> which means success. We code this with.</p>
<pre class="hljs"><code><div>    <span class="hljs-built_in">return</span> Ok(artist);
</div></code></pre>
<p>This returns.</p>
<p><img src="assets/images/get-artist-by-id.jpg" alt="Results" title="Results"></p>
<p>If nothing has been returned we can report the error with a response of 404, Not Found with this code.</p>
<pre class="hljs"><code><div>    <span class="hljs-built_in">return</span> NotFound($<span class="hljs-string">"An Artist with Name: {name} wasn't found!"</span>);
</div></code></pre>
<p><img src="assets/images/not-found.jpg" alt="Not Found" title="Not Found"></p>
<h2 id="understanding-data-transfer-objects-and-domain-models">Understanding Data Transfer Objects and Domain Models</h2>
<p><code>DTO's</code> or <code>Domain Transfer Objects</code> are objects that are used to transfer data between different components of an application.</p>
<p>They are simple objects that typically contain a subset of the properties in a Domain model or Entity and are designed to used for a specific purpose such as transferring data over the network or between layers of an application.</p>
<p><img src="assets/images/dtos.jpg" alt="Domain Transfer Objects" title="Domain Transfer Objects"></p>
<p>In this diagram we have our API and database. We use the Domain Model to move data between the API and Database. Because we are using Entity Framework our Domain Models have a mapping to the Database and the API. When you use EntityFramework to talk to a table it gives us the Domain Model because the DbContext only knows about the Domain Model. Because we have the Domain Model within the API it is a good practice to add a layer of Domain Transfer Objects (DTO's) and these are what we send back to the Client. So we should never send the Domain Models back to the client but we send the DTO's instead.</p>
<p>Once the DbContext is able to supply with a list of Domain Models we then do a mapping between the Domain Model and the DTO so we can send the DTO back to the client.</p>
<p>If it is information coming from the client, e.g. add a new resource then the client receives a DTO which we then convert from DTO to Domain Model and then we send the Domain Model to the Database using Entity Framework.</p>
<h3 id="advantages-of-domain-transfer-models">Advantages of Domain Transfer Models</h3>
<ul>
<li>Separation of concerns</li>
<li>Performance</li>
<li>Security</li>
<li>Versioning</li>
</ul>
<p>Domain Models could have more properties and differently named properties that we don't want to expose to our client.</p>
<p>You can improve performance of the application because we only retrieve the data that we need to send back to the client, not whole Entities.</p>
<p>DTO's help with security by not exposing all of the information to a client. You can reduce the risk of not sending sensitive data to unauthorised users.</p>
<h2 id="using-data-transfer-objects">Using Data Transfer Object's</h2>
<p>If you look at our <code>GetAll()</code> Action method you will see that we are using Domain Models to send data to the client.</p>
<p>We need to change this to stop exposing Domain Models to the client.</p>
<p>While you are learning how to use DTO's it is helpful to add comments to the Action method to show exactly what you are doing.</p>
<pre class="hljs"><code><div>	// GET: https://localhost:1234/api/artists
	[HttpGet]
	public async Task&lt;IActionResult&gt; <span class="hljs-function"><span class="hljs-title">GetAll</span></span>()
	{
		// GET data from the database - Domain Model
		var artists = await dbContext.Artist.ToListAsync();
	
		// MAP Domain Model to DTO
	
		// Return the DTO back to the client
		<span class="hljs-built_in">return</span> Ok(artists);
	}
</div></code></pre>
<p>We begin by creating a separate folder in the <code>Models</code> folder named <code>DTO</code>.</p>
<p>Add a class named <code>ArtistDto</code>.</p>
<pre class="hljs"><code><div>    public class ArtistDto
    {
        public int ArtistId { get; <span class="hljs-built_in">set</span>; } // identity field

        public string? FirstName { get; <span class="hljs-built_in">set</span>; }

        public string LastName { get; <span class="hljs-built_in">set</span>; }
        
        public string Name { get; <span class="hljs-built_in">set</span>; }

        public string? Biography { get; <span class="hljs-built_in">set</span>; }
    }
</div></code></pre>
<p>In this case we are creating a copy of the Artist Domain Model. By creating the <code>ArtistDto</code> we are decoupling our Artist Domain Model from the View layer of the API.</p>
<p>These are the modified Action methods from the <code>ArtistsController</code>.</p>
<pre class="hljs"><code><div>	// GET: https://localhost:1234/api/artists
	[HttpGet]
	public async Task&lt;IActionResult&gt; <span class="hljs-function"><span class="hljs-title">GetAll</span></span>()
	{
		// GET data from the database - Domain Model
		var artists = await dbContext.Artist.ToListAsync();
	
		// MAP Domain Model to DTO
		var artistsDto = new List&lt;ArtistDto&gt;();
	
		foreach (var artist <span class="hljs-keyword">in</span> artists)
		{
			artistsDto.Add(new <span class="hljs-function"><span class="hljs-title">ArtistDto</span></span>()
			{
				ArtistId = artist.ArtistId,
				FirstName = artist.FirstName,
				LastName = artist.LastName,
				Name = artist.Name,
				Biography = artist.Biography
			});
		}
	
		// Return the DTO back to the client
		<span class="hljs-built_in">return</span> Ok(artistsDto);
	}
	
	// GET: https://localhost:1234/api/artists/114
	[HttpGet]
	[Route(<span class="hljs-string">"{id:int}"</span>)]
	public async Task&lt;IActionResult&gt; GetById([FromRoute] int id)
	{
		// GET Artist Domain mode from database
		var artist = await dbContext.Artist.FirstOrDefaultAsync(a =&gt; a.ArtistId == id);
	
		<span class="hljs-keyword">if</span> (artist == null)
		{
			<span class="hljs-built_in">return</span> NotFound($<span class="hljs-string">"An Artist with Id: {id} wasn't found!"</span>);
		}
	
		// Map Artist Domain model to ArtistDto
		var artistDto = new ArtistDto 
		{
			ArtistId = artist.ArtistId,
			FirstName = artist.FirstName,
			LastName = artist.LastName,
			Name = artist.Name,
			Biography = artist.Biography
		};
	
		// Return the DTO back to the client 
		<span class="hljs-built_in">return</span> Ok(artistDto);
	}
</div></code></pre>
<h3 id="creating-a-new-artist">Creating a new Artist</h3>
<p>As we are going to use DTO's the first thing we will do is create an ArtistDto</p>
<p>We use the POST verb to create a new <code>Artist</code>.</p>
<pre class="hljs"><code><div>	// POST: https://localhost:1234/api/artists
	[HttpPost]
	public async Task&lt;IActionResult&gt; Create([FromBody] AddArtistDto addArtistDto)
	{
		// Map DTO to Domain Model
		var artist = new Artist
		{
			FirstName = addArtistDto.FirstName,
			LastName = addArtistDto.LastName,
			Name = addArtistDto.Name,
			Biography = addArtistDto.Biography
		};
	
		// Use Domain Model to create Artist
		await dbContext.Artist.AddAsync(artist);
		await dbContext.SaveChangesAsync();
	
		// Map Domain model back to DTO
		var artistDto = new ArtistDto
		{
			ArtistId = artist.ArtistId,
			FirstName = artist.FirstName,
			LastName = artist.LastName,
			Name = artist.Name,
			Biography = artist.Biography
		};
	
		<span class="hljs-built_in">return</span> CreatedAtAction(nameof(GetById), new {id = artistDto.ArtistId}, artistDto );
	}
</div></code></pre>
<p>In the method statement we are using the [FromBody] attribute because the data is being posted from the client.</p>
<p>The type of Body we are receiving is from the <code>AddArtistDto</code> DTO object. This object doesn't have an ArtistId.</p>
<pre class="hljs"><code><div>    // POST: https://localhost:1234/api/artists
	[HttpPost]
	public async Task&lt;IActionResult&gt; Create([FromBody] AddArtistDto addArtistDto)
	{
        ...
</div></code></pre>
<p>The first thing we have to do is Map the DTO to a Domain Model so we can work with the <code>DbContext</code> to send the data to the database.</p>
<pre class="hljs"><code><div>	// Map DTO to Domain Model
	var artist = new Artist
	{
		FirstName = addArtistDto.FirstName,
		LastName = addArtistDto.LastName,
		Name = addArtistDto.Name,
		Biography = addArtistDto.Biography
	};
</div></code></pre>
<p>Now we use the Domain Model to Add the <code>Artist</code> to the database</p>
<pre class="hljs"><code><div>    // Use Domain Model to create Artist
    await dbContext.Artist.AddAsync(artist);
    await dbContext.SaveChangesAsync();
</div></code></pre>
<p>After this we are going to Map the Domain Model back to the <code>Artist</code> DTO so that we can see the results.</p>
<pre class="hljs"><code><div>    // Map Domain model back to DTO
    var artistDto = new ArtistDto
    {
        ArtistId = artist.ArtistId,
        FirstName = artist.FirstName,
        LastName = artist.LastName,
        Name = artist.Name,
        Biography = artist.Biography
    };
</div></code></pre>
<p>Now we are ready to return the POST results.</p>
<pre class="hljs"><code><div>    <span class="hljs-built_in">return</span> CreatedAtAction(nameof(GetById), new {id = artistDto.ArtistId}, artistDto );
</div></code></pre>
<p>At first looks this return statement looks strange. We aren't using <code>return OK()</code> because that returns a <code>200</code> response and the POST needs to return a <strong>201</strong> response. We do that with a <code>return CreatedAtAction()</code> method. The <code>CreatedAtAction()</code> method needs an Action name to execute so we do this by using the <code>GetById()</code>  Action method.</p>
<p>Next we create a new object because want to pass the <code>ArtistId</code> property of the created object.</p>
<p>Finally we need to pass the new <code>artistDto</code> object that we created in the previous step.</p>
<p><img src="assets/images/post-response.jpg" alt="POST Response" title="POST Response"></p>
<p>There is one more interesting point to note in the Header.</p>
<blockquote>
<p>location: <a href="https://localhost:7262/api/Artists/864">https://localhost:7262/api/Artists/864</a></p>
</blockquote>
<p>It is the <code>GetById()</code> response and we can use this Url to find the newly created Artist object.</p>
<p>This is why we need to send back a <strong>201</strong> response rather than the <strong>200</strong> response that would only send back a message.</p>

</body>
</html>
